<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&lbrack;Leetcode Q238 &lpar;Medium&rpar;&colon;&rbrack;&lpar;https&colon;&sol;&sol;leetcode&period;com&sol;problems&sol;product-of-array-except-self&sol;&rpar; Product of Array Except Self</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="leetcode-q238-medium-product-of-array-except-self"><a href="https://leetcode.com/problems/product-of-array-except-self/">Leetcode Q238 (Medium):</a> Product of Array Except Self</h1>
<h2 id="problem-statements">Problem statements:</h2>
<ul>
<li>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</li>
<li>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</li>
<li>You must write an algorithm that runs in O(n) time and without using the division operation.</li>
</ul>
<br/>
<ul>
<li><strong>Constraints:</strong>
<ul>
<li>2 &lt;= nums.length &lt;= 105</li>
<li>-30 &lt;= nums[i] &lt;= 30</li>
<li>The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>Example 1:</strong>
<ul>
<li>Input: nums = [1,2,3,4]</li>
<li>Output: [24,12,8,6]</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>Example 2:</strong>
<ul>
<li>Input: nums = [-1,1,0,-3,3]</li>
<li>Output: [0,0,9,0,0]</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<p><strong>Follow up:</strong></p>
<ul>
<li>Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)</li>
</ul>
<hr/>
<h2 id="problem-analysis">Problem Analysis:</h2>
<ul>
<li>The problem asks us to compute an array answer where answer[i] is the product of all elements in the input array nums except for nums[i].</li>
<li>We must solve this without using the division operator and in O(n) time complexity.</li>
<li>An additional challenge is to achieve O(1) extra space complexity, where the output array does not count towards the space.</li>
</ul>
<hr/>
<h3 id="edge-cases">Edge Cases:</h3>
<ul>
<li>
<p><strong>Zeros in the array:</strong></p>
<ul>
<li>
<p><strong>One zero:</strong></p>
<ul>
<li>If nums contains a single zero, say at index k, then answer[k] will be the product of all non-zero elements.</li>
<li>For all other indices i, answer[i] will be 0, as the product of all elements except nums[i] will include the zero.</li>
</ul>
</li>
<li>
<p><strong>Multiple zeros:</strong></p>
<ul>
<li>If nums contains two or more zeros, the product of all elements is 0.</li>
<li>Consequently, the product of all elements except any single one will also be 0. Thus, all elements in the answer array will be 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Negative numbers:</strong></p>
<ul>
<li>The approach must correctly handle negative numbers. The resulting product at each index could be positive or negative.</li>
</ul>
</li>
<li>
<p><strong>Constraints:</strong></p>
<ul>
<li>The problem states the array length is at least 2, so we don't need to worry about a single-element array.</li>
</ul>
</li>
</ul>
<hr/>
<h2 id="solutions">Solutions:</h2>
<h3 id="brute-force-approach-nested-loop">Brute-Force Approach (Nested loop):</h3>
<ul>
<li>A straightforward solution is to iterate through the array, and for each element at index i, iterate again to calculate the product of all other elements.</li>
</ul>
<br/>
<ul>
<li><strong>Algorithm:</strong>
<ul>
<li>Initialize an empty result array answer of the same size as nums.</li>
<li>Iterate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> to n-1.
<ul>
<li>For each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, initialize a current_product = 1.</li>
<li>Iterate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> from 0 to n-1.</li>
<li>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is not equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>, multiply current_product by nums[j].</li>
<li>Store current_product in answer[i].</li>
</ul>
</li>
<li>Return answer.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>Complexity:</strong>
<ul>
<li>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The nested loops result in a time complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
<li>It is not optimal and fails the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> constraint.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity:</strong></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> for the result array.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="optimized-approach-prefix-and-suffix-products">Optimized Approach (Prefix and Suffix Products)</h3>
<ul>
<li>The core idea is to precompute the products of elements to the left of each index and the products of elements to the right of each index.</li>
<li>The product for a given index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is then simply the product of its left and right segments.</li>
</ul>
<br/>
<ul>
<li><strong>Algorithm:</strong>
<ul>
<li>
<p>Initialize 3 arrays of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>: left_products, right_products, and answer.</p>
</li>
<li>
<p><strong>Left Products Pass:</strong></p>
<ul>
<li>Set left_products[0] = 1.</li>
<li>Iterate from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>:
<ul>
<li>left_products[i] = left_products[i-1] * nums[i-1].</li>
</ul>
</li>
<li><strong>Note:</strong>
<ul>
<li>After this loop, left_products[i] holds the product of all elements to the left of nums[i].</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Right Products Pass:</strong></p>
<ul>
<li>Set right_products[n-1] = 1.</li>
<li>Iterate from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i = n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> down to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>:
<ul>
<li>right_products[i] = right_products[i+1] * nums[i+1].</li>
</ul>
</li>
<li><strong>Note:</strong>
<ul>
<li>After this loop, right_products[i] holds the product of all elements to the right of nums[i].</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Final Product Pass:</strong></p>
<ul>
<li>Iterate from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>:
<ul>
<li>answer[i] = left_products[i] * right_products[i].</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return answer array.</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>Complexity:</strong>
<ul>
<li><strong>Time Complexity:</strong>
<ul>
<li>Three separate passes through the array, each taking <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time. So, total time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> which will be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Space Complexity:</strong>
<ul>
<li>We use two additional arrays of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, so the space complexity is O(2n), ignoring constants it will be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="most-optimized-approach-o1-extra-space">Most Optimized Approach: O(1) Extra Space</h3>
<ul>
<li>We can optimize the space complexity by reusing the output array to store the prefix products and then calculating the suffix products in a single pass while populating the final result.</li>
</ul>
<br/>
<ul>
<li><strong>Algorithm:</strong>
<ul>
<li>
<p>Initialize an array answer of size n.</p>
</li>
<li>
<p><strong>First Pass (Prefix Products):</strong></p>
<ul>
<li>Set answer[0] = 1.</li>
<li>Iterate from i = 1 to n-1:
<ul>
<li>answer[i] = answer[i-1] * nums[i-1].</li>
</ul>
</li>
<li><strong>Note:</strong>
<ul>
<li>At the end of this loop, answer[i] contains the product of all elements to the left of nums[i].</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Second Pass (Suffix Products):</strong></p>
<ul>
<li>Initialize a variable right_product = 1.</li>
<li>Iterate from i = n-1 down to 0:
<ul>
<li>Update answer[i] by multiplying its current value (the left product) with right_product.</li>
<li>Update right_product by multiplying it with nums[i] for the next iteration.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return answer array.</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>Complexity:</strong>
<ul>
<li><strong>Time Complexity:</strong>
<ul>
<li>Two passes through the array, resulting in a total time complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Space Complexity:</strong>
<ul>
<li>We only use a single variable right_product in addition to the output array.</li>
<li>The problem statement allows the output array to not be counted as extra space.</li>
<li>Thus, the space complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. This is the optimal solution.</li>
</ul>
</li>
</ul>
<hr/>
<h4 id="java-implemention-1---optimized-approach-prefix-and-suffix-products">Java Implemention 1 - Optimized Approach (Prefix and Suffix Products):</h4>
<pre><code class="language-java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) {
        
        <span class="hljs-comment">// Handle edge cases for an empty or null input array.</span>
        <span class="hljs-comment">// Although the problem guarantees nums.length &gt;= 2, this is robust practice.</span>
        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;
        <span class="hljs-type">int</span>[] prefixProducts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];
        <span class="hljs-type">int</span>[] suffixProducts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];
        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];

        <span class="hljs-comment">// First pass: Populate the prefixProducts array.</span>
        <span class="hljs-comment">// prefixProducts[i] stores the product of all elements to the left of index i.</span>
        prefixProducts[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) {
            prefixProducts[i] = prefixProducts[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];
        }

        <span class="hljs-comment">// Second pass: Populate the suffixProducts array.</span>
        <span class="hljs-comment">// suffixProducts[i] stores the product of all elements to the right of index i.</span>
        suffixProducts[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            suffixProducts[i] = suffixProducts[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>];
        }

        <span class="hljs-comment">// Third pass: Combine the prefix and suffix products to get the final result.</span>
        <span class="hljs-comment">// The product of all elements except nums[i] is the product of elements to its left</span>
        <span class="hljs-comment">// and the product of elements to its right.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            result[i] = prefixProducts[i] * suffixProducts[i];
        }

        <span class="hljs-keyword">return</span> result;
    }
</code></pre>
<br/>
<hr/>
<h4 id="java-implemention---most-optimized-approach-o1-extra-space">Java Implemention - Most Optimized Approach: O(1) Extra Space:</h4>
<pre><code class="language-java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) {
        
        <span class="hljs-comment">// Handle edge case where the input array is null or empty.</span>
        <span class="hljs-comment">// Although the problem constraints state nums.length &gt;= 2, this is a good practice.</span>
        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];
        
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;
        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];

        <span class="hljs-comment">// First pass: Calculate prefix products and store them in the result array.</span>
        <span class="hljs-comment">// res[i] will hold the product of all elements to the left of nums[i].</span>
        <span class="hljs-comment">// For the first element, there are no elements to its left, so the product is 1.</span>
        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
            res[i+<span class="hljs-number">1</span>] = nums[i] * res[i];
        }
        
        <span class="hljs-comment">// Second pass: Calculate suffix products and combine with the prefix products.</span>
        <span class="hljs-comment">// `sp` (suffix product) keeps track of the product of elements to the right of the current index.</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-comment">// Multiply the current prefix product (in res[i]) with the suffix product.</span>
            <span class="hljs-comment">// This gives the product of all elements except nums[i].</span>
            res[i] = res[i] * sp;
            <span class="hljs-comment">// Update the suffix product for the next iteration.</span>
            sp *= nums[i];
        }

        <span class="hljs-keyword">return</span> res;
    }
</code></pre>
<hr>
<center>
<h3> ------ End ------ </h3>
</center>
<!-- HTML styling -->
<style>
  table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
  }
  heading {
    color: blue;
    font-size: 20px;
  }
</style>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>